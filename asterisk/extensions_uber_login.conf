[general]
static=yes
writeprotect=no
clearglobalvars=no

; ==================================================
; CONTEXTO PRINCIPAL - RAMAIS INTERNOS
; ==================================================
[from-internal]

; ---------- CHAMADAS ENTRE RAMAIS ----------
exten => _3X,1,NoOp(Chamada direta para ramal ${EXTEN})
 same => n,Dial(PJSIP/${EXTEN},20)
 same => n,Hangup()

; ---------- ACESSO À FILA ----------
exten => 900,1,Goto(fila-uber-vez,s,1)


; ============================================================
; UBER VEZ (FIFO) - Login/Logout + chamada 1x e desloga
; Regras:
; - Login adiciona no final da lista (ordem FIFO)
; - Entrada: chama o 1º da lista
; - Atendeu: remove da lista (já removido antes de chamar) e encerra
; - Não atendeu: remove da lista e tenta o próximo
; ============================================================

; -------------------------------
; Códigos internos (discados pelos agentes)
; *931 = LOGIN (entra na vez)
; *932 = LOGOUT (sai da vez)
; *933 = STATUS (mostra lista no CLI e fala algo simples)
; -------------------------------
[uber-vez-codes]
exten => *931,1,NoOp(UBER VEZ LOGIN | CALLERID=${CALLERID(num)})
 same => n,Set(AGENT=${CALLERID(num)})
 same => n,GotoIf($["${AGENT}"=""]?bad,1)

 ; só aceita 31/32/33 (pra evitar alguém qualquer logar)
 same => n,GotoIf($[${REGEX("^(31|32|33)$" ${AGENT})}=0]?bad,1)

 same => n,Gosub(uber-vez-add,s,1(${AGENT}))
 same => n,Playback(beep)
 same => n,Hangup()

exten => bad,1,NoOp(UBER VEZ LOGIN INVALIDO | CALLERID=${CALLERID(num)})
 same => n,Playback(invalid)
 same => n,Hangup()


exten => *932,1,NoOp(UBER VEZ LOGOUT | CALLERID=${CALLERID(num)})
 same => n,Set(AGENT=${CALLERID(num)})
 same => n,GotoIf($["${AGENT}"=""]?bad,1)
 same => n,Gosub(uber-vez-remove,s,1(${AGENT}))
 same => n,Playback(beep)
 same => n,Hangup()


exten => *933,1,NoOp(UBER VEZ STATUS)
 same => n,Set(LIST=${DB(ubervez/list)})
 same => n,NoOp(UBER VEZ LISTA ATUAL = ${LIST})
 same => n,Playback(beep)
 same => n,Hangup()


; -------------------------------
; SUBROTINA: adicionar agente no final (sem duplicar)
; ARG1 = ramal do agente
; -------------------------------
[uber-vez-add]
exten => s,1,NoOp(ADD AGENT=${ARG1})
 same => n,Set(AGENT=${ARG1})
 same => n,Set(LIST=${DB(ubervez/list)})

 ; Se já existe na lista, não adiciona
 same => n,Set(EXISTS=${REGEX("(^|\\|)${AGENT}(\\||$)" ${LIST})})
 same => n,GotoIf($[${EXISTS}=1]?done)

 ; Se lista vazia, vira só o agente
 same => n,GotoIf($["${LIST}"=""]?setfirst)

 ; Senão, concatena no final com |
 same => n,Set(LIST=${LIST}|${AGENT})
 same => n,Set(DB(ubervez/list)=${LIST})
 same => n,Goto(done)

 same => n(setfirst),Set(DB(ubervez/list)=${AGENT})
 same => n(done),NoOp(LISTA NOVA = ${DB(ubervez/list)})
 same => n,Return()


; -------------------------------
; SUBROTINA: remover agente da lista
; ARG1 = ramal do agente
; -------------------------------
[uber-vez-remove]
exten => s,1,NoOp(REMOVE AGENT=${ARG1})
 same => n,Set(AGENT=${ARG1})
 same => n,Set(LIST=${DB(ubervez/list)})
 same => n,GotoIf($["${LIST}"=""]?done)

 ; Protege com | no começo/fim
 same => n,Set(WORK=|${LIST}|)

 ; Remove exatamente |AGENT|
 same => n,Set(WORK=${REPLACE(${WORK},|${AGENT}|,|)})

 ; Remove barras duplicadas (faz duas passadas pra garantir)
 same => n,Set(WORK=${REPLACE(${WORK},||,|)})
 same => n,Set(WORK=${REPLACE(${WORK},||,|)})

 ; Tira | do começo e do fim
 same => n,Set(WORK=${IF($["${WORK:0:1}"="|"]?${WORK:1}:${WORK})})
 same => n,Set(WORK=${IF($["${WORK:-1}"="|"]?${WORK:0:-1}:${WORK})})

 same => n,Set(DB(ubervez/list)=${WORK})
 same => n(done),NoOp(LISTA NOVA = ${DB(ubervez/list)})
 same => n,Return()


; -------------------------------
; SUBROTINA PRINCIPAL: atender 1 chamada usando a "vez"
; Chame com: Gosub(uber-vez,s,1)
; -------------------------------

[uber-vez]
exten => s,1,NoOp(UBER VEZ START | CALLERID=${CALLERID(num)} | EXTEN=${EXTEN})
 same => n,Set(TRY=0)

 ; loop: tenta até achar alguém na lista (ou esvaziar)
 same => n(loop),Set(LIST=${DB(ubervez/list)})
 same => n,NoOp(LISTA ATUAL=${LIST})

 ; se lista vazia: encerra (ou você pode mandar pra outra fila)
 same => n,GotoIf($["${LIST}"=""]?empty)

 ; pega o primeiro da lista (da vez)
 same => n,Set(AGENT=${CUT(LIST,,1)})

 ; remove o primeiro da lista IMEDIATAMENTE (desloga sempre, atenda ou não)
 same => n,Set(NEWLIST=)
 same => n,Set(CNT=${FIELDQTY(LIST,,)})
 same => n,Set(I=2)
 same => n,While($[${I}<=${CNT}])
  same => n,Set(ITEM=${CUT(LIST,,${I})})
  same => n,ExecIf($["${NEWLIST}"=""]?Set(NEWLIST=${ITEM}):Set(NEWLIST=${NEWLIST},${ITEM}))
  same => n,Set(I=$[${I}+1])
 same => n,EndWhile()
 same => n,Set(DB(ubervez/list)=${NEWLIST})

 same => n,NoOp(DA VEZ=${AGENT} | LISTA APOS REMOVER=${DB(ubervez/list)})

 ; tenta chamar o agente por X segundos
 same => n,Set(TRY=$[${TRY}+1])
 same => n,Dial(PJSIP/${AGENT},26)

 ; se atendeu, acabou (já deslogou)
 same => n,GotoIf($["${DIALSTATUS}"="ANSWER"]?done)

 ; não atendeu/ocupado/indisponível -> tenta o próximo
 same => n,NoOp(NAO ATENDEU (${DIALSTATUS}) -> PROXIMO)
 same => n,Goto(loop)

 same => n(empty),NoOp(SEM AGENTES LOGADOS NA VEZ)
 ; opcional: mandar pra fila uber normal como fallback:
  same => n,Queue(uber,t)
 same => n,Hangup()

 same => n(done),Hangup()


