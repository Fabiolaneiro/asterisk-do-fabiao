; ==============================
; RUA - LOGIN/LOGOUT PADRONIZADO
; Login:  *<ramal>  (ex: *71 discado pelo ramal 71)
; Logout: #<ramal>  (ex: #71 discado pelo ramal 71)
; Contexto do endpoint: rua-agent-codes
; ==============================

[rua-agent-codes]

exten => _*X.,1,NoOp(RUA LOGIN | Discado=${EXTEN} | CID=${CALLERID(num)})
 same => n,Set(AGENT=${FILTER(0-9,${EXTEN:1})})
 same => n,Set(ORIGEM=${FILTER(0-9,${CALLERID(num)})})

 ; valida: só o próprio ramal pode logar ele mesmo
 same => n,GotoIf($["${AGENT}"="" || "${ORIGEM}"=""]?bad)
 same => n,GotoIf($["${ORIGEM}"="${AGENT}"]?ok:bad)

 same => n(bad),NoOp(RUA LOGIN INVALIDO | AGENT=${AGENT} ORIGEM=${ORIGEM})
 same => n,Playback(invalid)
 same => n,Hangup()

 same => n(ok),NoOp(RUA LOGIN OK | agente=${AGENT})

 ; garante exclusividade: tira de "base/mesa" e limpa presença anterior
 same => n,Gosub(taxi-varal-remove,s,1(${AGENT}))
 same => n,DBDeltree(taxi/present_ts/${AGENT})
 same => n,DBDeltree(taxi/present_base/${AGENT})
 same => n,DBDeltree(taxi/present_loc/${AGENT})

 ; (1) se logar de novo, desassocia corrida do cliente
 same => n,Gosub(taxi-end-ride-if-any,s,1(${AGENT}))

 ; marca presença como "rua"
 same => n,Set(DB(taxi/present_ts/${AGENT})=${EPOCH})
 same => n,Set(DB(taxi/present_base/${AGENT})=${AGENT})
 same => n,Set(DB(taxi/present_loc/${AGENT})=rua)

 ; entra na fila rua mantendo prioridade FIFO via penalty
 same => n,Set(IFACE=Local/${AGENT}@rua-member-dial/n)
 same => n,Set(N=${DB(rua/seq)})
 same => n,Set(N=${IF($["${N}"=""]?0:${N})})
 same => n,Set(N=$[${N}+1])
 same => n,Set(DB(rua/seq)=${N})
 same => n,RemoveQueueMember(rua,${IFACE})
 same => n,AddQueueMember(rua,${IFACE},${N})

 same => n,Playback(beep)
 same => n,Hangup()


exten => _#X.,1,NoOp(RUA LOGOUT | Discado=${EXTEN} | CID=${CALLERID(num)})
 same => n,Set(AGENT=${FILTER(0-9,${EXTEN:1})})
 same => n,Set(ORIGEM=${FILTER(0-9,${CALLERID(num)})})

 same => n,GotoIf($["${AGENT}"="" || "${ORIGEM}"=""]?bad)
 same => n,GotoIf($["${ORIGEM}"="${AGENT}"]?ok:bad)

 same => n(bad),NoOp(RUA LOGOUT INVALIDO | AGENT=${AGENT} ORIGEM=${ORIGEM})
 same => n,Playback(invalid)
 same => n,Hangup()

 same => n(ok),Set(IFACE=Local/${AGENT}@rua-member-dial/n)
 same => n,RemoveQueueMember(rua,${IFACE})
 same => n,DBDeltree(taxi/present_ts/${AGENT})
 same => n,DBDeltree(taxi/present_base/${AGENT})
 same => n,DBDeltree(taxi/present_loc/${AGENT})
 same => n,Playback(beep)
 same => n,Hangup()


[rua-member-handler]
exten => s,1,NoOp(RUA MEMBER HANDLER | iface=${MEMBERINTERFACE} | dialstatus=${DIALSTATUS} | queuestatus=${QUEUESTATUS})

 ; Segurança: se por algum motivo não veio interface, sai
 same => n,GotoIf($["${MEMBERINTERFACE}"=""]?done)

 ; Remove SEMPRE após a tentativa (atendeu ou não)
 ; Isso garante: "tocou pra ele uma vez, sai da fila"
 same => n,RemoveQueueMember(rua,${MEMBERINTERFACE})

 same => n,NoOp(RUA REMOVIDO DA FILA | iface=${MEMBERINTERFACE})
 same => n(done),Return()


; ======================================================
; Cada membro da fila rua toca via Local/<ramal>@rua-member-dial/n
; Aqui nós:
; - Dial(PJSIP/<ramal>,30)
; - depois do Dial terminar (ANSWER ou NOANSWER), removemos o membro da fila
; ======================================================

[rua-member-dial]
exten => _X.,1,NoOp(RUA MEMBER DIAL | ramal=${EXTEN} | uniqueid=${UNIQUEID} | CID=${CALLERID(num)})
 same => n,Set(AGENT=${EXTEN})
 same => n,Set(IFACE=Local/${AGENT}@rua-member-dial/n)

 ; remove da fila ANTES de discar (regra: tocou uma vez, sai da fila)
 same => n,NoOp(REMOVENDO ANTES DE TOCAR: ${IFACE})
 same => n,RemoveQueueMember(rua,${IFACE})

 ; >>> AQUI É O PULO DO GATO: grava corrida no AstDB quando atender
 same => n,Dial(PJSIP/${AGENT},30,U(taxi-onanswer^${AGENT}^${CALLERID(num)}^rua))

 same => n,Hangup()
