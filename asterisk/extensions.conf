[general]
static=yes
writeprotect=no
clearglobalvars=no
[globals]
CONSOLE=Console/dsp				; Console interface for demo
TRUNK=DAHDI/G2					; Trunk interface
TRUNKMSD=1					; MSD digits to strip (usually 1 or 0)

[dundi-e164-customers]

[dundi-e164-via-pstn]

[dundi-e164-local]
include => dundi-e164-canonical
include => dundi-e164-customers
include => dundi-e164-via-pstn

[dundi-e164-switch]
switch => DUNDi/e164

[dundi-e164-lookup]
[dundi-e164]
exten => s,1,Goto(${ARG1},1)
include => dundi-e164-lookup

[iax2-trunk]
[iaxprovider]

[trunkint]
exten => _9011.,1,Gosub(dundi-e164,s,1(${EXTEN:4}))
;	same => n,Hangup()
exten => _9011.,n,Dial(${GLOBAL(TRUNK)}/${FILTER(0-9,${EXTEN:${GLOBAL(TRUNKMSD)}})})

[trunkld]
[trunklocal]
exten => _9NXXXXXX,1,Dial(${GLOBAL(TRUNK)}/${EXTEN:${GLOBAL(TRUNKMSD)}})

[trunktollfree]
exten => _91800NXXXXXX,1,Dial(${GLOBAL(TRUNK)}/${EXTEN:${GLOBAL(TRUNKMSD)}})
exten => _91888NXXXXXX,1,Dial(${GLOBAL(TRUNK)}/${EXTEN:${GLOBAL(TRUNKMSD)}})
exten => _91877NXXXXXX,1,Dial(${GLOBAL(TRUNK)}/${EXTEN:${GLOBAL(TRUNKMSD)}})
exten => _91866NXXXXXX,1,Dial(${GLOBAL(TRUNK)}/${EXTEN:${GLOBAL(TRUNKMSD)}})

[international]
ignorepat => 9
include => longdistance
include => trunkint

[longdistance]
;
; Master context for long distance
;
ignorepat => 9
include => local
include => trunkld

[local]
;
; Master context for local and toll-free calls only
;
ignorepat => 9
include => default
include => trunklocal
include => iax2-trunk
include => trunktollfree
include => iaxprovider

;Include parkedcalls (or the context you define in features conf)
;to enable call parking.
include => parkedcalls
;
; You can use an alternative switch type as well, to resolve
; extensions that are not known here, for example with remote
; IAX switching you transparently get access to the remote
; Asterisk PBX
;
; switch => IAX2/user:password@bigserver/local
;
; An "lswitch" is like a switch but is literal, in that
; variable substitution is not performed at load time
; but is passed to the switch directly (presumably to
; be substituted in the switch routine itself)
;
; lswitch => Loopback/12${EXTEN}@othercontext
;
; An "eswitch" is like a switch but the evaluation of
; variable substitution is performed at runtime before
; being passed to the switch routine.
;
; eswitch => IAX2/context@${CURSERVER}

; The following two contexts are a template to enable the ability to dial
; ISN numbers. For more information about what an ISN number is, please see
; http://www.freenum.org.
;
; This is the dialing hook.  use:
; include => outbound-freenum

[outbound-freenum]
[outbound-freenum2]
exten => _X!,1,Verbose(2,Performing ISN lookup for ${EXTEN})
	same => n,Set(SUFFIX=${CUT(EXTEN,*,2-)})                                ; make sure the suffix is all digits as well
	same => n,GotoIf($["${FILTER(0-9,${SUFFIX})}" != "${SUFFIX}"]?fn-CONGESTION,1)
                                                                        ; filter out bad characters per the README-SERIOUSLY.best-practices.txt document
	same => n,Set(TIMEOUT(absolute)=10800)
	same => n,Set(isnresult=${ENUMLOOKUP(${EXTEN},sip,,1,freenum.org)})     ; perform our lookup with freenum.org
	same => n,GotoIf($["${isnresult}" != ""]?from)
	same => n,Set(DIALSTATUS=CONGESTION)
	same => n,Goto(fn-CONGESTION,1)
	same => n(from),Set(__SIPFROMUSER=${CALLERID(num)})
	same => n,GotoIf($["${GLOBAL(FREENUMDOMAIN)}" = ""]?dial)               ; check if we set the FREENUMDOMAIN global variable in [global]
	same => n,Set(__SIPFROMDOMAIN=${GLOBAL(FREENUMDOMAIN)})                 ;    if we did set it, then we'll use it for our outbound dialing domain
	same => n(dial),Dial(SIP/${isnresult},40)
	same => n,Goto(fn-${DIALSTATUS},1)

exten => fn-BUSY,1,Busy()

exten => _f[n]-.,1,NoOp(ISN: ${DIALSTATUS})
same => n,Congestion()

[trunkdial]
exten => s,1,StackPop()
	same => n,Dial(${ARG1})
exten => s,n,Goto(s-${DIALSTATUS},1)
exten => s-NOANSWER,1,Hangup()
exten => s-BUSY,1,PlayTones(busy)
	same => n,Wait(60)
	same => n,Hangup()
exten => s-CHANUNAVAIL,1,PlayTones(congestion)
	same => n,Wait(60)
	same => n,Hangup()
exten => s-CONGESTION,1,PlayTones(congestion)
	same => n,Wait(60)
	same => n,Hangup()
exten => _s-.,1,NoOp(${DIALSTATUS})
	same => n,Hangup()

[stdexten]
exten => _X.,50000(stdexten),NoOp(Start stdexten)
	same => n,Set(LOCAL(ext)=${EXTEN})
	same => n,Set(LOCAL(dev)=${ARG1})
	same => n,Set(LOCAL(cntx)=${ARG2})
	same => n,Set(LOCAL(mbx)=${ext}${IF($[!${ISNULL(${cntx})}]?@${cntx})})
	same => n,Dial(${dev},20)				; Ring the interface, 20 seconds maximum
	same => n,Goto(stdexten-${DIALSTATUS},1)		; Jump based on status (NOANSWER,BUSY,CHANUNAVAIL,CONGESTION,ANSWER)

exten => stdexten-NOANSWER,1,VoiceMail(${mbx},u)	; If unavailable, send to voicemail w/ unavail announce
	same => n,Return()			; If they press #, return to start

exten => stdexten-BUSY,1,VoiceMail(${mbx},b)		; If busy, send to voicemail w/ busy announce
	same => n,Return()			; If they press #, return to start

exten => _stde[x]te[n]-.,1,Goto(stdexten-NOANSWER,1)	; Treat anything else as no answer

exten => a,1,VoiceMailMain(${mbx})			; If they press *, send the user into VoicemailMain
exten => a,n,Return()

[stdPrivacyexten]
exten => _X.,60000(stdPrivacyexten),NoOp(Start stdPrivacyexten)
	same => n,Set(LOCAL(ext)=${ARG1})
	same => n,Set(LOCAL(dev)=${ARG2})
	same => n,Set(LOCAL(dontcntx)=${ARG3})
	same => n,Set(LOCAL(tortcntx)=${ARG4})
	same => n,Set(LOCAL(cntx)=${ARG5})

exten => _X.,n,Set(LOCAL(mbx)="${ext}"$["${cntx}" ? "@${cntx}" :: ""])
	same => n,Dial(${dev},20,p)			; Ring the interface, 20 seconds maximum, call screening
						; option (or use P for databased call _X.screening)
	same => n,Goto(stdexten-${DIALSTATUS},1)		; Jump based on status (NOANSWER,BUSY,CHANUNAVAIL,CONGESTION,ANSWER)

exten => stdexten-NOANSWER,1,VoiceMail(${mbx},u)	; If unavailable, send to voicemail w/ unavail announce
	same => n,NoOp(Finish stdPrivacyexten NOANSWER)
	same => n,Return()			; If they press #, return to start

exten => stdexten-BUSY,1,VoiceMail(${mbx},b)		; If busy, send to voicemail w/ busy announce
	same => n,NoOp(Finish stdPrivacyexten BUSY)
	same => n,Return()			; If they press #, return to start

exten => stdexten-DONTCALL,1,Goto(${dontcntx},s,1)	; Callee chose to send this call to a polite "Don't call again" script.

exten => stdexten-TORTURE,1,Goto(${tortcntx},s,1)	; Callee chose to send this call to a telemarketer torture script.

exten => _stde[x]te[n]-.,1,Goto(stdexten-NOANSWER,1)	; Treat anything else as no answer

exten => a,1,VoiceMailMain(${mbx})		; If they press *, send the user into VoicemailMain
	same => n,Return()

[sub-page]
;
; Paging subroutine:
;
;       Check to see if SIP device is in use and DO NOT PAGE if they are
;
;   ${ARG1} - Device to page
exten => s,1,ChanIsAvail(${ARG1},s)			; s is for ANY call
	same => n,GotoIf($["${AVAILSTATUS}" = "1"]?autoanswer:fail)
	same => n(autoanswer),Set(_ALERT_INFO="RA")			; This is for the PolyComs
	same => n,SIPAddHeader(Call-Info: Answer-After=0)	; This is for the Grandstream, Snoms, and Others
	same => n,NoOp()					; Add others here and Post on the Docs!!!!
	same => n,Dial(${ARG1})
	same => n(fail),Hangup()

[demo]
include => stdexten
;
; We start with what to do when a call first comes in.
;
exten => s,1,Wait(1)			; Wait a second, just for fun
	same => n,Answer()			; Answer the line
	same => n,Set(TIMEOUT(digit)=5)	; Set Digit Timeout to 5 seconds
	same => n,Set(TIMEOUT(response)=10)	; Set Response Timeout to 10 seconds
	same => n(restart),BackGround(demo-congrats)	; Play a congratulatory message
	same => n(instruct),BackGround(demo-instruct)	; Play some instructions
	same => n,WaitExten()		; Wait for an extension to be dialed.

exten => 2,1,BackGround(demo-moreinfo)	; Give some more information.
exten => 2,n,Goto(s,instruct)

exten => 3,1,Set(CHANNEL(language)=fr)		; Set language to french
	same => n,Goto(s,restart)		; Start with the congratulations

exten => 1000,1,Goto(default,s,1)
;
; We also create an example user, 1234, who is on the console and has
; voicemail, etc.
;
exten => 1234,1,Playback(transfer,skip)		; "Please hold while..."
					; (but skip if channel is not up)
	same => n,Gosub(${EXTEN},stdexten(${GLOBAL(CONSOLE)}))
	same => n,Goto(default,s,1)		; exited Voicemail

exten => 1235,1,VoiceMail(1234,u)		; Right to voicemail

exten => 1236,1,Dial(Console/dsp)		; Ring forever
	same => n,VoiceMail(1234,b)		; Unless busy

;
; # for when they're done with the demo
;
exten => #,1,Playback(demo-thanks)	; "Thanks for trying the demo"
	same => n,Hangup()			; Hang them up.

;
; A timeout and "invalid extension rule"
;
exten => t,1,Goto(#,1)			; If they take too long, give up
exten => i,1,Playback(invalid)		; "That's not valid, try again"

;
; Create an extension, 600, for evaluating echo latency.
;
exten => 600,1,Playback(demo-echotest)	; Let them know what's going on
	same => n,Echo()			; Do the echo test
	same => n,Playback(demo-echodone)	; Let them know it's over
	same => n,Goto(s,6)		; Start over

;
;	You can use the page subroutine to intercom a individual user
exten => 76245,1,Gosub(page,s,1(SIP/Grandstream1))
; or if your peernames are the same as extensions
exten => _7XXX,1,Gosub(page,s,1(SIP/${EXTEN}))
;
;
; System Wide Page at extension 7999
;
exten => 7999,1,Set(TIMEOUT(absolute)=60)
	same => n,Page(Local/Grandstream1@page&Local/Xlite1@page&Local/1234@page/n,d)

; Give voicemail at extension 8500
;
exten => 8500,1,VoiceMailMain()
	same => n,Goto(s,6)
;
; Here's what a phone entry would look like (IXJ for example)
;
;exten => 1265,1,Dial(Phone/phone0,15)
;	same => n,Goto(s,5)

;
;	The page context calls up the sub-page subroutine that sets variables needed for auto-answer
;	It is in is own context to make calling it from the Page() application as simple as
;	Local/{peername}@page
;
[page]
exten => _X.,1,Gosub(sub-page,s,1(SIP/${EXTEN}))
	same => n,Hangup()

;[mainmenu]
;
; Example "main menu" context with submenu
;
;exten => s,1,Answer
;	same => n,Background(thanks)		; "Thanks for calling press 1 for sales, 2 for support, ..."
;	same => n,WaitExten
;exten => 1,1,Goto(submenu,s,1)
;exten => 2,1,Hangup
;include => default
;
;[submenu]
;exten => s,1,Ringing					; Make them comfortable with 2 seconds of ringback
;	same => n,Wait,2
;	same => n,Background(submenuopts)	; "Thanks for calling the sales department.  Press 1 for steve, 2 for..."
;	same => n,WaitExten
;exten => 1,1,Goto(default,steve,1)
;exten => 2,1,Goto(default,mark,2)

[public]
;
; ATTENTION: If your Asterisk is connected to the internet and you do
; not have allowguest=no in sip.conf, everybody out there may use your
; public context without authentication.  In that case you want to
; double check which services you offer to the world.
;
include => demo

[default]
;
; By default we include the demo.  In a production system, you
; probably don't want to have the demo there.
;
include => demo

;
; An extension like the one below can be used for FWD, Nikotel, sipgate etc.
; Note that you must have a [sipprovider] section in sip.conf
;
;exten => _41X.,1,Dial(SIP/${FILTER(0-9,${EXTEN:2})}@sipprovider,,r)

; Real extensions would go here. Generally you want real extensions to be
; 4 or 5 digits long (although there is no such requirement) and start with a
; single digit that is fairly large (like 6 or 7) so that you have plenty of
; room to overlap extensions and menu options without conflict.  You can alias
; them with names, too, and use global variables

;exten => 6245,hint,SIP/Grandstream1&SIP/Xlite1(Joe Schmoe) ; Channel hints for presence
;exten => 6245,1,Dial(SIP/Grandstream1,20,rt)	; permit transfer
;exten => 6245,n(dial),Dial(${HINT},20,rtT)	; Use hint as listed
;exten => 6245,n,VoiceMail(6245,u)		; Voicemail (unavailable)
;exten => 6245,s+1,Hangup			; s+1, same as n
;exten => 6245,dial+101,VoiceMail(6245,b)	; Voicemail (busy)
;exten => 6361,1,Dial(IAX2/JaneDoe,,rm)		; ring without time limit
;exten => 6389,1,Dial(MGCP/aaln/1@192.168.0.14)
;exten => 6390,1,Dial(JINGLE/caller/callee) ; Dial via jingle using labels
;exten => 6391,1,Dial(JINGLE/asterisk@digium.com/mogorman@astjab.org) ;Dial via jingle using asterisk as the transport and calling mogorman.
;exten => 6394,1,Dial(Local/6275/n)		; this will dial ${MARK}

;exten => 6275,1,Gosub(${EXTEN},stdexten(${MARK}))
						; assuming ${MARK} is something like DAHDI/2
;exten => 6275,n,Goto(default,s,1)		; exited Voicemail
;exten => mark,1,Goto(6275,1)			; alias mark to 6275
;exten => 6536,1,Gosub(${EXTEN},stdexten(${WIL}))
						; Ditto for wil
;	same => n,Goto(default,s,1)		; exited Voicemail
;exten => wil,1,Goto(6236,1)

;If you want to subscribe to the status of a parking space, this is
;how you do it. Subscribe to extension 6600 in sip, and you will see
;the status of the first parking lot with this extensions' help
;exten => 6600,hint,park:701@parkedcalls
;exten => 6600,1,noop
;
;To subscribe to the availability of a free member in the 'markq' queue.
;Note: '_avail' is added to the QueueName
;exten => 8501,hint,Queue:markq_avail
;exten => 8501,1,Queue(markq)
;
; You can also monitor the status of a queue by providing a hint for a
; particular queue name.
;exten => 8502,hint,Queue:markq
;exten => 8502,1,Queue(markq)
;
; Some other handy things are an extension for checking voicemail via
; voicemailmain
;
;exten => 8500,1,VoicemailMain
;	same => n,Hangup
;
; Or a conference room (you'll need to edit meetme.conf to enable this room)
;
;exten => 8600,1,Meetme(1234)
;
; Or playing an announcement to the called party, as soon it answers
;
;exten = 8700,1,Dial(${MARK},30,A(/path/to/my/announcemsg))
;

; example of a compartmentalized company called "acme"
;
; this is the context that your incoming IAX/SIP trunk dumps you in...
;[acme-incoming]
;exten => s,1,Wait(1)
;	same => n,Answer() ; "same" allows you to continue an extension more
;			concisely without having to repeat the extension or pattern
;	same => n(menu),Playback(acme/vm-brief-menu)
;	same => n(exten),Background(vm-enter-num-to-call)
;	same => n,WaitExten(5)
;	same => n(goodbye),Playback(vm-goodbye)
;	same => n(end),Hangup()
;
;include  => acme-extens
;
;exten => i,1,Playback(vm-invalid)
;	same => n,Goto(s,exten)			; optionally, transfer to operator
;
;exten => t,1,Goto(s,goodbye)
;
; this is the context our internal SIP hardphones use (see sip.conf)
;
;[acme-internal]
;exten => s,1,Answer()
;	same => n(exten),Background(vm-enter-num-to-call)
;	same => n,WaitExten(5)
;	same => n(goodbye),Playback(vm-goodbye)
;	same => n(end),Hangup()
;
;include => trunkint
;include => trunkld
;include => trunklocal
;
;include => acme-extens
;
; you can test what your system sounds like to outside callers by dialing this
;exten => 777,1,DISA(no-password,acme-incoming)
;
; grouping of acme's extensions... never used directly, always included.
;
;[acme-extens]
;include => stdexten
;exten => 111,1,Gosub(111,stdexten(SIP/pete_1,acme))
;	same => n,Goto(s,exten)
;
;exten => 112,1,Gosub(112,stdexten(SIP/nancy_1,acme))
;	same => n,Goto(s,end)
;
; end of acme example

;
; Time context: you can patch this in via the following.
;
; [acme-internal]
; ...
; exten => 777,1,Gosub(time)
; exten => 777,n,Hangup()
;
; ...
; include => time
;
; Note: if you're geographically spread out, you can have SIP extensions
; specify their own local timezone in sip.conf as:
;
; [boi]
; type=friend
; context=acme-internal
; callerid="Boise Ofc. <2083451111>"
; ...
; ; use system-wide default timezone of MST7MDT
;
; [lws]
; type=friend
; context=acme-internal
; callerid="Lewiston Ofc. <2087431111>"
; ...
; setvar=timezone=PST8PDT
;
; "timezone" isn't a 'reserved' name in any way, and other places where
; the timezone is significant (e.g. calls to "SayUnixTime()", etc) will
; require modification as well.  Note that voicemail.conf already has
; a mechanism for timezones.
;

[time]
exten => _X.,30000(time),NoOp(Time: ${EXTEN} ${timezone})
	same => n,Wait(0.25)
	same => n,Answer()
; the amount of delay is set for English; you may need to adjust this time
; for other languages if there's no pause before the synchronizing beep.
	same => n,Set(FUTURETIME=$[${EPOCH} + 12])
	same => n,SayUnixTime(${FUTURETIME},Zulu,HNS)
	same => n,SayPhonetic(z)
; use the timezone associated with the extension (sip only), or system-wide
; default if one hasn't been set.
	same => n,SayUnixTime(${FUTURETIME},${timezone},HNS)
	same => n,Playback(spy-local)
	same => n,WaitUntil(${FUTURETIME})
	same => n,Playback(beep)
	same => n,Return()

;
; ANI context: use in the same way as "time" above
;

[ani]
exten => _X.,40000(ani),NoOp(ANI: ${EXTEN})
	same => n,Wait(0.25)
	same => n,Answer()
	same => n,Playback(vm-from)
	same => n,SayDigits(${CALLERID(ani)})
	same => n,Wait(1.25)
	same => n,SayDigits(${CALLERID(ani)})	; playback again in case of missed digit
	same => n,Return()

; For more information on applications, just type "core show applications" at your
; friendly Asterisk CLI prompt.
;
; "core show application <command>" will show details of how you
; use that particular application in this file, the dial plan.
; "core show functions" will list all dialplan functions
; "core show function <COMMAND>" will show you more information about
; one function. Remember that function names are UPPER CASE.

; Examples using PJSIPNotify application.
;[generate-notify]
;
; Send a NOTIFY with the following headers inside the SIP dialog for the current channel:
;
;	Event: Test
;	X-Data: Fun
;
;exten => 6880,1,noOp()
;    same => n,Answer()
;    same => n,PJSIPNotify(,&Event=Test&X-Data=Fun)
;    same => n,Wait(1)
;    same => n,Hangup()
;
; Send a NOTIFY with the following headers to bob's custom uri. This requries a
; default outbound endpoint to be configured in pjsip.conf.
;
;	Event: Test
;	X-Data: Over
;
;exten => 6881,1,noOp()
;    same => n,Answer()
;    same => n,PJSIPNotify(<sip:bob@127.0.0.1:5260>,&Event=Test&X-Data=Over)
;    same => n,Wait(1)
;    same => n,Hangup()
;
; Send a NOTIFY with the the custom headers defined in pjsip_notify.conf under
; 'custom-notify-1' inside the SIP dialog for the current channel.
;
;exten => 6882,1,noOp()
;    same => n,Answer()
;    same => n,PJSIPNotify(,custom-notify-1)
;    same => n,Wait(1)
;    same => n,Hangup()
; Send a NOTIFY with the following headers and body to bob's custom uri. This
; requries a default outbound endpoint to be configured in pjsip.conf.
;
;	Event: Custom
;
;	Content-Type: application/voicemail
;	Content-Length:    14
;
;	check-messages
;
;exten => 6882,1,noOp()
;    same => n,Answer()
;    same => n,PJSIPNotify(,&Event=Custom&Content-type=application/voicemail&Content=check-messages&Content=)
;    same => n,Wait(1)
;    same => n,Hangup()

; ============================================================
;  CONTEXTO DE ENTRADA (quando você criar o tronco/DID)
;  Depois você vai apontar o tronco para context=incoming
; ============================================================
[incoming]
exten => _+55X.,1,Goto(main,500,1)
exten => _X.,1,Goto(main,500,1)
exten => s,1,Goto(main,500,1)
; Exemplo genérico: qualquer chamada que entre cai no 500 (fluxo principal)


; ============================================================
;  CONTEXTO INTERNO (ramais / mesa / códigos)
;  Seus endpoints hoje estão em context=from-internal, então usamos ele
; ============================================================
[from-internal]
include => internal
include => mesa-login
include => mototaxi-login
include => ride-codes
include => main
include => uber-vez-codes

; ============================================================
;  RAMAIS (exemplo: seus mototáxis 21..24 e mesa 5500/5600/6100)
;  Ajuste/expanda depois (você disse que terá ~40)
; ============================================================
[internal]
; mesa (se quiser discagem direta)
exten => 5500,1,Dial(PJSIP/5500,20)
 same => n,Hangup()
exten => 5600,1,Dial(PJSIP/5600,20)
 same => n,Hangup()
exten => 6100,1,Dial(PJSIP/6100,20)
 same => n,Hangup()
exten => 999,1,NoOp(ODBC_TEST=${ODBC_TEST()})
 same => n,Hangup()


; mototáxis (exemplo inicial)
exten => 21,1,Dial(PJSIP/21,20)
 same => n,Hangup()
exten => 22,1,Dial(PJSIP/22,20)
 same => n,Hangup()
exten => 23,1,Dial(PJSIP/23,20)
 same => n,Hangup()
exten => 24,1,Dial(PJSIP/24,20)
 same => n,Hangup()


; ============================================================
;  FLUXO PRINCIPAL DO CLIENTE
;  - Se cliente já tem corrida ativa -> manda direto pro mototáxi
;  - Senão:
;      - Se tem alguém logado na MESA -> toca 15s na mesa
;      - Se não tem ninguém logado -> vai direto mototáxi
;      - Mototáxi: fica esperando até alguém logar e atender
; ============================================================
[main]
exten => 500,1,NoOp(INBOUND - caller=${CALLERID(num)})

 ; 1) se callerid está em corrida ativa (<= 1h) -> vai direto pro mototáxi
 same => n,Set(CLIENT=${CALLERID(num)})
 same => n,Set(RIDE_AGENT=${DB(ride/${CLIENT}/agent)})
 same => n,Set(RIDE_START=${DB(ride/${CLIENT}/start)})
 same => n,GotoIf($["${RIDE_AGENT}"=""]?checkmesa:checkttl)

 same => n(checkttl),Set(NOW=${EPOCH})
 same => n,GotoIf($[${NOW} - ${RIDE_START} <= 3600]?toagent:expire)

 same => n(expire),NoOp(RIDE EXPIRED -> cleanup for client ${CLIENT})
 same => n,DBdel(ride/${CLIENT}/agent)
 same => n,DBdel(ride/${CLIENT}/start)
 same => n,DBdel(ride/${CLIENT}/rec)
 same => n,Set(OLDAG=${DB(agentride/${RIDE_AGENT}/client)})
 same => n,DBdel(agentride/${RIDE_AGENT}/client)
 same => n,DBdel(agentride/${RIDE_AGENT}/start)
 same => n,Goto(checkmesa)

 same => n(toagent),NoOp(ROUTE BACK TO AGENT ${RIDE_AGENT})
 same => n,Dial(PJSIP/${RIDE_AGENT},20)
 same => n,Hangup()

 ; 2) fluxo normal
 same => n(checkmesa),Set(MESA_COUNT=${DB(mesa/count)})
 same => n,GotoIf($[${MESA_COUNT} > 0]?ringmesa:tomototaxi)

 ; 2a) toca MESA por 15s (6s por mesa, rrmemory), se não atender -> transborda
 same => n(ringmesa),Answer()
 same => n,Queue(mesa,t,,,15)
 same => n,NoOp(QUEUESTATUS mesa=${QUEUESTATUS})
 same => n,Goto(tomototaxi)

 ; 2b) fila mototáxi: fica até alguém atender (sem timeout)
 same => n(tomototaxi),Answer()
 same => n,Queue(mototaxi,t)
 same => n,Hangup()


; ============================================================
;  "MEMBROS" DA FILA MESA (Local/5500@mesa-member/n etc)
;  - Se não tem mototáxi logado naquele ramal da mesa: falha rápido (pula)
;  - Se tocar e não atender em 6s: desloga automaticamente (perdeu a vez)
;  - Se atender: cria corrida em andamento e (consome a vez) desloga da mesa
; ============================================================

[mesa-member]
; Chamado pela fila MESA via Local/<AGENT>@mesa-member
exten => _2X,1,NoOp(MESA MEMBER - agent=${EXTEN} caller=${CALLERID(num)})
 same => n,Set(AGENT=${EXTEN})

 ; descobre qual mesa esse agente escolheu
 same => n,Set(MESA=${DB(mesa/map/${AGENT})})
 same => n,GotoIf($["${MESA}"=""]?nomap:call)

 same => n(nomap),NoOp(SEM MAP mesa/map/${AGENT} - removendo da fila)
 same => n,RemoveQueueMember(mesa,Local/${AGENT}@mesa-member/n)
 same => n,Hangup()

 ; toca na mesa por 6s (sua regra de auto-logout em caso de não atender)
 same => n(call),NoOp(Tocando mesa ${MESA} por 6s)
 same => n,Dial(PJSIP/${MESA},6)

 ; se não atendeu: tira da fila e limpa DB (perde a vez)
 same => n,GotoIf($["${DIALSTATUS}"="ANSWER"]?answered:missed)

 same => n(missed),NoOp(MISSED -> auto-logout agente ${AGENT})
 same => n,RemoveQueueMember(mesa,Local/${AGENT}@mesa-member/n)
 same => n,DBdel(mesa/map/${AGENT})
 same => n,Hangup()

 ; se atendeu: aqui você chama sua rotina “corrida em andamento” e desloga
 same => n(answered),NoOp(ANSWERED -> deslogar agente ${AGENT} da mesa)
 same => n,RemoveQueueMember(mesa,Local/${AGENT}@mesa-member/n)
 same => n,DBdel(mesa/map/${AGENT})
 same => n,Hangup()



;[mesa-member]
;exten => _XXXX,1,NoOp(MESA MEMBER - mesa=${EXTEN} caller=${CALLERID(num)})
 ;same => n,Set(MESA=${EXTEN})
 ;same => n,Set(AGENT=${DB(mesa/${MESA})})
 ;same => n,GotoIf($["${AGENT}"!=""]?call:skip)

 ;same => n(skip),Busy(1)
 ;same => n,Hangup()

 ;same => n(call),NoOp(MESA=${MESA} AGENT_LOGADO=${AGENT})

 ; toca no telefone da mesa por 6s
 ;same => n,Dial(PJSIP/${MESA},6)

 ; se não atendeu: perde vez -> desloga
 ;same => n,GotoIf($["${DIALSTATUS}"="ANSWER"]?answered:missed)

 ;same => n(missed),NoOp(MISSED -> auto logout mesa/${MESA} (agent ${AGENT}))
 ;same => n,DBdel(mesa/${MESA})
 ;same => n,Set(MESA_COUNT=${DB(mesa/count)})
 ;same => n,Set(DB(mesa/count)=${IF($[${MESA_COUNT} > 0]?${MESA_COUNT}-1:0)})
 ;same => n,Hangup()

 ; atendeu: cria corrida (cliente<->agente) + gravação + consome vez (desloga)
 ;same => n(answered),NoOp(ANSWERED -> create ride client=${CALLERID(num)} agent=${AGENT})

 ;same => n,Set(CLIENT=${CALLERID(num)})
 ;same => n,Set(NOW=${EPOCH})

 ; gravação
 ;same => n,Set(RECFILE=ride-${CLIENT}-${AGENT}-${STRFTIME(${NOW},,%Y%m%d-%H%M%S)}.wav)
 ;same => n,MixMonitor(${RECFILE},a)

 ; status corrida (dupla mão)
 ;same => n,Set(DB(ride/${CLIENT}/agent)=${AGENT})
 ;same => n,Set(DB(ride/${CLIENT}/start)=${NOW})
 ;same => n,Set(DB(ride/${CLIENT}/rec)=${RECFILE})

 ;same => n,Set(DB(agentride/${AGENT}/client)=${CLIENT})
 ;same => n,Set(DB(agentride/${AGENT}/start)=${NOW})

 ; mototáxi em corrida não pode ficar logado na fila mototáxi
 ;same => n,RemoveQueueMember(mototaxi,Local/${AGENT}@mototaxi-member/n)

 ; consome vez na mesa
 ;same => n,DBdel(mesa/${MESA})
 ;same => n,Set(MESA_COUNT=${DB(mesa/count)})
 ;same => n,Set(DB(mesa/count)=${IF($[${MESA_COUNT} > 0]?${MESA_COUNT}-1:0)})

 ;same => n,Hangup()


; ============================================================
;  LOGIN NA MESA (feito no telefone 5500/5600/6100):
;    *21, *22, ... define "quem é o próximo"
;  Regras:
;    - Só aceita se discou de 5500/5600/6100
;    - Só aceita se agente NÃO estiver em corrida
;    - Marca DB(mesa/<ramal>)=<agente> e incrementa count (se estava vazio)
; ============================================================

[mesa-login]
; LOGIN: *2X  (ex: *22) discado a partir da mesa 5500/5600/6100
exten => _*2X,1,NoOp(MESA LOGIN - mesa=${PJSIP_ENDPOINT} caller=${CALLERID(num)} ext=${EXTEN})
 same => n,Set(MESA=${PJSIP_ENDPOINT})
 same => n,Set(AGENT=${EXTEN:1})

 ; valida ramal mesa
 same => n,GotoIf($[${REGEX("^(5500|5600|6100)$" ${MESA})}]?okmesa:bad)
 same => n(bad),Playback(pm-invalid-option)
 same => n,Hangup()

 ; valida agente (ajuste aqui o range real: 20-29, 21-24, etc)
 same => n(okmesa),GotoIf($[${REGEX("^(20|21|22|23|24|25|26|27|28|29)$" ${AGENT})}]?okagent:bad2)
 same => n(bad2),Playback(pm-invalid-option)
 same => n,Hangup()

 ; bloqueia se estiver em corrida (se você usa esse controle)
 same => n(okagent),Set(INRIDE=${DB(agentride/${AGENT}/client)})
 same => n,GotoIf($["${INRIDE}"=""]?go:deny)
 same => n(deny),Playback(vm-incorrect)
 same => n,Hangup()

 ; grava o mapeamento AGENT -> MESA
 same => n(go),Set(DB(mesa/map/${AGENT})=${MESA})

 ; adiciona na fila MESA (Local channel é built-in no Asterisk 20)
 same => n,AddQueueMember(mesa,Local/${AGENT}@mesa-member/n)

 same => n,Playback(agent-loginok)
 same => n,Hangup()


; LOGOUT MANUAL: *00XX (ex: *0022) - remove da fila mesa e limpa DB
exten => _*00XX,1,NoOp(MESA LOGOUT MANUAL - ext=${EXTEN})
 same => n,Set(AGENT=${EXTEN:3})
 same => n,RemoveQueueMember(mesa,Local/${AGENT}@mesa-member/n)
 same => n,DBdel(mesa/map/${AGENT})
 same => n,Playback(agent-loggedoff)
 same => n,Hangup()


;essa foi criada no inicio mas depois ele mandou substituir pela debaixo
;[mesa-login]
;exten => _*2X,1,NoOp(MESA LOGIN - mesa=${PJSIP_ENDPOINT} ext=${EXTEN})
; same => n,Set(MESA=${PJSIP_ENDPOINT})
; same => n,Set(AGENT=${EXTEN:1})

 ; valida ramal mesa
; same => n,GotoIf($[${REGEX("^(5500|5600|6100)$" ${MESA})}]?okmesa:bad)
; same => n(bad),Playback(pm-invalid-option)
; same => n,Hangup()

 ; valida agente (exemplo inicial 21-24, depois você amplia)
; same => n(okmesa),GotoIf($[${REGEX("^(21|22|23|24)$" ${AGENT})}]?okagent:bad)
 ;same => n(bad),Playback(pm-invalid-option)
 ;same => n,Hangup()

;[mesa-login]
; ============================================================
; LOGIN NA FILA MESA (varal)
; - Discar *2X no telefone da mesa (5600/5500/6100) para logar o mototáxi 20-29
; - Mantém contador /mesa/count para o fluxo do 500
; - Bloqueia login se o mototáxi estiver "em corrida"
; ============================================================

;exten => _*2X,1,NoOp(LOGIN MESA - Mototaxi ${EXTEN:1} - origin=${CALLERID(num)} endpoint=${PJSIP_ENDPOINT})
; same => n,Set(MOTO=${EXTEN:1})

 ; valida MOTO 20-29
; same => n,GotoIf($[${MOTO} >= 20 & ${MOTO} <= 29]?chkride:bad)

 ; bloqueia login se está em corrida
; same => n(chkride),Set(INRIDE=${DB(agentride/${MOTO}/client)})
; same => n,GotoIf($["${INRIDE}"=""]?doadd:inride)

; same => n(inride),Playback(vm-incorrect)
 ;same => n,Hangup()

#include extensions_uber.conf
#include extensions_uber_login.conf

